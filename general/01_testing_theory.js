// Testing Theory

// - Testing objectives
// -- To provide sufficient information to stakeholders regarding the level of quality of the test object
// -- To verify whether all specified requirements have been fulfilled (verification)
// -- To check whether the test object is complete and if it works as the users and stakeholders expect (validation)
// -- To prevent defects by evaluate work products such as requirements, user stories, design, and code
// -- To find defects and failures thus reduce the level of risk of inadequate software quality
// -- To build confidence in the level of quality of the test object
// -- To comply with contractual, legal, or regulatory requirements or standards

// - Testing principles
// -- Testing shows the presence of defects, not their absence
// -- Exhaustive testing is impossible
// -- Early testing saves time and money
// -- Defects cluster together
// -- Beware of pesticide paradox
// -- Testing is context dependent
// -- Absence-of-errors is a fallacy (validation)

// - Testing process and SDLC
// -- Monitoring and Control during all testing phases
// -- Testing process - Planning - Analysis - Design - Implementation - Execution - Completion
// -- SDLC - Planning - Analysis - Design - Development - Integration and Testing - Deployment - Maintenance

// - Testing levels
// -- Component/Unit/Module/Program testing
// -- Component integration testing
// -- System integration testing
// -- System testing
// -- Acceptance testing (User Acceptance Testing and Operational Acceptance Testing)

// - Testing types
// -- Functional (what the system should do - completeness, correctness, appropriateness)
// -- Non-Functional (how well the system behaves - security, compatibility, portability, performance, reliability, robustness, maintainability)
// -- Change related (regression and re-test/confirmation testing)

// - Testing techniques (test design techniques)
// -- White-box (statement, branch, decision, condition, multiple condition, path)
// -- Black-box (equivalence partitioning, boundary values analysis, decision table, state transition, use case, pairwise)
// -- Experienced based (error guessing, exploratory, checklist-based)
